# 객체는 인터페이스를 사용해 참조하라

## ⛳️ 목표

- 객체를 참조할 때 인터페이스를 사용하는 이유에 대해 이해하자.

<br>

## 📄 핵심 요약

---

### **인터페이스 사용의 이점**

1. **유연성 증가**
    - 인터페이스로 참조하면 구현 클래스를 자유롭게 교체할 수 있다.
    - 변경 시 생성자만 수정하면 되므로 유지보수가 용이하다.

   ```java
   // 좋은 예 : 인터페이스를 타입으로 사용
   Set<String> set = new LinkedHashSet<>();

   // 클래스 교체가 용이
   set = new HashSet<>();
   ```

2. **결합도 감소**
    - 구현체에 의존하지 않으므로 다른 클래스와의 결합도를 낮춘다.
    - 추후 변경 및 확장에 용이하다.

3. **코드 재사용성 증가**
    - 표준 인터페이스로 작성된 코드는 다양한 구현체와 호환된다.

4. **가독성과 유지보수성 향상**
    - 인터페이스를 사용하면 객체의 역할이 명확히 드러나고, 코드 이해가 쉬워진다.

<br>

### **주의사항**

1. **특정 구현체에 종속된 기능 사용 시 문제 발생**
    - 구현 클래스에만 있는 기능에 의존하면 유연성이 떨어진다.
    - 예 : `LinkedHashSet`의 순서 보장 기능에 의존하는 경우 이를 `HashSet`으로 교체하면 문제가 발생할 수 있다.

2. **적합한 인터페이스가 없는 경우**
    - `String`, `BigDecimal`과 같은 값 클래스는 인터페이스가 없으므로 클래스 타입으로 참조해도 무방하다.
    - Java I/O 패키지의 클래스처럼 추상 클래스 기반의 프레임워크에서는 추상 클래스를 참조할 수 있다.

3. **인터페이스에 없는 특별한 메서드**
    - 특정 클래스의 고유 메서드를 사용해야 하는 경우 인터페이스로 참조하지 못할 수 있다.
    - 예 : `PriorityQueue`의 `comparator()` 메서드

<br>

### **구체적 사용 예시**

1. **인터페이스로 참조**
   ```java
   // 좋은 예
   List<String> list = new ArrayList<>();
   list.add("Effective Java");

   // 필요에 따라 구현체 교체
   list = new LinkedList<>();
   ```

2. **구현체에 의존하지 않는 프로그래밍**
   ```java
   // 클래스 의존 제거
   Map<String, Integer> map = new HashMap<>();
   map.put("Java", 21);
   ```

3. **구현체에 따라 동작이 달라질 경우**
    - 필요 시 적절한 구현체 선택
        - `LinkedHashMap`으로 순서 보장
        - `EnumMap`으로 성능 향상 (키가 열거 타입인 경우)

<br>

### 💡 **핵심 정리**

1. **인터페이스 사용 습관화**
    - 변수, 반환 타입, 매개변수 선언 시 인터페이스를 우선 사용하자.

2. **구현체 교체의 용이성**
    - 유지보수성을 높이고, 코드의 유연성을 확보할 수 있다.

3. **클래스 사용은 제한적으로**
    - 적합한 인터페이스가 없거나, 특정 기능에 의존해야 할 경우에만 클래스 타입을 사용하라.

4. **구현체와 역할 분리**
    - 객체의 역할에 집중하여 인터페이스 기반으로 설계하면, 더 나은 확장성과 유지보수성을 제공한다.