# 박싱된 기본 타입보다는 기본 타입을 사용하라

## ⛳️ 목표

박싱된 기본 타입과 기본 타입의 차이점을 이해하고 활용해야 할 때를 알아보자

<br>

## 📄 핵심 요약

***기본 타입을 사용해야 하는 이유***

- 박싱된 기본 타입으로 식별성을 검사할 수 있다.
- 박싱된 기본 타입은 null을 가질 수 있다.
- 박싱된 기본 타입이 상대적으로 메모리와 시간 리소스를 더 소모한다.

<br>

***박싱된 기본 타입을 사용하는 경우***

- 컬렉션
- 타입 매개변수
- 리플렉션 - 메서드 호출

---

## 자바의 데이터 타입

**[1] 기본 타입**

- int
- double
- boolean 등

<br>

**[2] 참조 타입 (=박싱된 기본 타입)**

- Integer
- Double
- Boolean 등

<br>

## 기본 타입과 박싱된 기본 타입(참조 타입)의 차이점

오토박싱과 오토언박싱 덕분에 두 타입을 크게 구분하지 않고 사용할 수는 있지만, 차이가 있기 때문에 주의해서 선택해야 한다.

<br>

**[1] 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성(identity)이란 속성을 갖는다.**

```java
Comparator<Integer> naturalOrder =
	(i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```

- 박싱된 기본 타입에 `==`연산자를 사용하면 값이 아닌 식별성을 검사하게 된다.
- 값을 비교하려면 박싱된 기본 타입을 각각 기본 타입 정수로 저장한 변수를 통해 위의 코드를 수행해야 한다.

<br>

**[2] 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값, null을 가질 수 있다.**

```java
public class Unbelievable {
	static Integer i;
	
	public static void main(String[] args) {
		if (i == 42) {
			System.out.println("믿을 수 없군!");
		}
	}
}
```

- i의 초깃값은 `null`이기에 `NullPointerException`이 발생한다.
- 기본 타입과 박싱된 기본 타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀리며, null 참조를 언박싱하면 NPE가 발생하는 것이다.
- i를 int로 바꿔서 위의 코드를 수행해야 한다.

<br>

**[3] 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.**

```java
public static void main(String[] args) {
	Long sum = 0L;
	for (long i = 0; i <= Integer.MAX_VALUE; i++) {
		sum += i;
	}
	System.out.println(sum);
}
```

- 지역변수 sum을 박싱된 기본타입으로 선언했기에 박싱과 언박싱이 반복해서 일어나 성능이 느려진다.

<br>

## 박싱된 기본 타입을 사용하는 경우

**[1] 컬렉션의 원소, 키 값**

컬렉션은 기본 타입을 담을 수 없으므로 박싱된 기본 타입을 사용한다.

<br>

**[2] 매개변수화 타입, 매개변수화 메서드의 타입 매개변수**

자바 언어가 타입 매개변수로 기본 타입을 지원하지 않기 때문이다.

<br>

**[3] 리플렉션**

리플렉션을 통해 메서드를 호출할 때 박싱된 기본 타입을 사용한다.

<br>

```text
핵심 정리

기본 타입과 박싱된 기본 타입 중 하나를 선택해야 한다면 가능하면 기본 타입을 사용하라. 기본타입은 간단하고 빠르다.

```
