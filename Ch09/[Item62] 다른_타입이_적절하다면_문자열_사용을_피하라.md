# 다른 타입이 적절하다면 문자열 사용을 피하라

## ⛳️ 목표

문자열 타입보다 적절한 타입을 찾아 사용해야 하는 이유를 알아보자

<br>

## 📄 핵심 요약

- 문자열은 잘못 사용했을 때 번거롭고 덜 유연하며, 느리고 오류 가능성이 크다.
- 열거 타입을 생성하거나 전용 클래스, 혹은 타입을 활용하여 리팩토링을 시도하자.

---

## 문자열은 다른 값 타입을 대신하기에 적합하지 않다

- 입력받을 데이터가 문자열이 아닌 수치형이라면 적당한 수치 타입으로 변환하자.
- 기본 타입이든, 참조 타입이든 적절한 값 타입이 있다면 그것을 사용하고 없다면 새로 하나 작성하라.

<br>

### [1] 열거 타입

상수를 열거할 때는 문자열보다 열거 타입이 월등히 낫다.

> 참고. 아이템 34
> 
> [정수 및 문자열 열거 타입보다 열거 타입이 나은 이유]
> - 열거 타입으로 상수를 다룰 때의 타입 안정성을 보장할 수 있다.
> - 상수의 의미를 파악하기 쉬우며 메서드나 필드를 추가해 추가 연산을 수행할 수 있다.
>

<br>

### [2] 혼합 타입

여러 요소가 혼합된 데이터를 하나의 문자열로 표현하는 것은 대체로 좋지 않다.

```java
String compoundKey = className + "#" + i.next();
```

- 구분자가 각 요소에 포함되었을 경우 문제가 발생할 수 있다.
- 각 요소를 개별로 접근할 때 문자열 파싱이 필요하기에 느리고 번거로우며 오류 가능성이 커진다.
- String이 제공하는 기능에만 의존해야 하므로 전용 클래스를 만드는 것이 좋다.

<br>

### [3] 권한

다음은 클라이언트가 제공한 문자열 키로 스레드별 지역변수를 식별한 코드이다.

<br>

***AS-IS : 문자열 기반 API***

```java
public class ThreadLocal {
	private ThreadLocal() { } // 객체 생성 불가
	
	// 현 스레드의 값을 키로 구분해 저장한다.
	public static void set(String key, Object value);
	
	// (키가 가리키는) 현 스레드의 값을 반환한다.
	public static Object get(String key);
}
```

- 스레드 구분용 문자열 키가 전역으로 공유된다.
- 악의적인 의도로 같은 키를 사용하여 다른 클라이언트의 값을 가져올 수 있다.

<br>

***TO-BE : 타입 기반 API***

```java
public final class ThreadLocal<T> {
	public ThreadLocal(); 
	public void set(T value);
	public T get();
}
```

- 제네릭 사용으로 타입 안정성을 확보했다.
- 키를 잘못 관리했을 때의 문제를 방지하기 위해 스레드 자체에 고유한 데이터를 저장한다.
- static 메서드를 사용하지 않고 각 ThreadLocal 객체가 독립적으로 값을 저장하고 관리하도록 했다.