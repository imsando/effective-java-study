# Serializable을 구현할지는 신중히 결정하라

## ⛳️ 목표

직렬화 구현 시 장기적인 관점을 고려해야 하는 이유를 알아보자.

<br>

## 📄 핵심 요약

- 직렬화된 클래스는 공개 API가 되므로 수정이 어렵기 때문에 설계 시 신중해야 한다.
- 역직렬화로 불변식이 깨질 위험이 있으며, 보안 취약점이 존재한다.
- 상속용 혹은 내부 클래스는 직렬화를 피하고, 정적 멤버 클래스만 허용하는 것이 좋다.

---

## Serializable 구현의 문제

- Serializable을 구현하면 릴리스한 뒤에는 수정하기 어렵다.
- 직렬화된 바이트 스트림 인코딩(직렬화 형태)도 하나의 공개 API가 되기 때문에 클래스가 널리 퍼지면 그 직렬화 형태도 영원히 지원해야 한다.
- 기본 직렬화 형태에서는 클래스의 private, package-private 인스턴스 필드들마저 API로 공개되어 캡슐화가 깨진다.
- **즉, 직렬화 가능 클래스를 만들 때는 장기적인 관점에서 고려하여 잘 설계해야 한다.**

<Br>

### 문제점 1: 클래스 개선 방해

- 모든 직렬화된 클래스는 `고유 식별 번호(serialVersionUID)`를 부여받는다.
- 명시하지 않으면 시스템이 런타임에 암호 해시 함수(SHA-1)을 적용해 자동으로 클래스 안에 생성해 넣는다.
    - 고려되는 정보 : 클래스 이름, 구현한 인터페이스, 대부분의 클래스 멤버들
- 고려되는 정보 중 하나라도 변경될 시 직렬 버전 UID도 변경되므로 자동 생성되는 값에 의존하면 쉽게 호환성이 깨져버려 런타임에 `InvalidClassException`이 발생한다.

<br>

### 문제점 2: 버그와 보안 위험성 증가

- 직렬화는 언어의 기본 메커니즘(생성자를 사용한 객체 생성)을 우회하는 객체 생성 기법이다.
- 기본 역직렬화를 사용하면 불변식 깨짐과 허가되지 않은 접근에 쉽게 노출된다.

<br>

### 문제점 3: 테스트 항목 증가

- 직렬화 가능 클래스가 수정될 때는 신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화할 수 있는지, 그 반대의 경우도 가능한지 검사해야 하므로 테스트해야 할 양이 릴리스 횟수에 비해 증가한다.

<br>

## Serializable 구현 시 주의점

> 역사적으로 BigInteger와 Instant같은 ‘값’ 클래스와 컬렉션 클래스들은 Serializable을 구현하고, 스레드 풀처럼 ‘동작’하는 객체를 표현하는 클래스들은 대부분 Serializable을 구현하지 않았다.
>

**[1] 상속용으로 설계된 클래스는 대부분 Serializable을 구현하면 안 된다.**

- 인터페이스도 대부분 Serializable을 확장해서는 안 된다.

**[2] 인스턴스 필드 값 중 불변식을 보장해야 할 게 있다면 반드시 하위 클래스에서 finalize 메서드를 재정의하지 못하게 해야 한다.**

- 그렇지 않으면 `finalizer` 공격을 당할 수 있다.

**[3] 인스턴스 필드 중 기본값으로 초기화되면 위배되는 불변식이 있다면 클래스에 readObjectNoData 메서드를 반드시 추가해야 한다.**

- `readObjectNoData` 메서드는 기존의 직렬화 가능 클래스에 직렬화 가능 상위 클래스를 추가하는 경우를 위해 쓰인다.

**[4] 상속용 클래스에서 하위 클래스가 직렬화를 지원하려 할 때 역직렬화하려면 그 상위 클래스는 매개변수가 없는 생성자를 제공해야 한다.**

- 그렇지 않으면 직렬화 프록시 패턴(아이템 90)을 사용해야 한다.

**[5] 내부 클래스는 직렬화를 구현하지 말아야 한다.**

- 컴파일러가 생성하여 자동으로 추가된 필드들이 어떻게 클래스 정의에 추가되는지 명확하지 않기 때문이다.

**[6] 정적 멤버 클래스는 Serializable을 구현해도 된다.**