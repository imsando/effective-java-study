# 자바 직렬화의 대안을 찾으라

## ⛳️ 목표

직렬화 문제에 대처하는 방법을 알아보자

<br>

## 📄 핵심 요약

- 자바 직렬화는 **보안 취약점, 유지보수성 문제, 성능 저하** 등의 단점이 있다.
- 역직렬화 과정에서 **원격 코드 실행(RCE), 서비스 거부(DOS) 공격** 등의 위협이 발생할 수 있다.
- 직렬화 대신 크로스-플랫폼 구조화된 데이터 표현을 활용해야 한다.
- 직렬화를 어쩔 수 없이 사용해야 할 경우에는 신뢰할 수 없는 데이터는 역직렬화하지 말아야 한다.

---

## 직렬화의 문제점

> 2000년대 초반에 논의된 직렬화의 취약점들이 그 후로 십 년 이상 심각하게 악용되었다.
*보이지 않는 생성자, API와 구현 사이의 모호해진 경계, 성능, 보안, 유지보수성 등*
2016년 11월에는 샌프란시스코 시영 교통국이 랜섬웨어 공격을 받아 요금 징수 시스템이 이틀간 마비되는 사태를 겪기도 했다.
>
- 공격 범위가 너무 넓고 지속적으로 더 넓어져 방어하기 어렵다.
- Serializable 인터페이스를 구현했다면, ObjectInputStream의 readObject 메서드는 클래스패스 안의 거의 모든 타입의 객체를 만들어 낼 수 있다. (모든 타입들의 코드 전체가 공격 범위)

<br>

> 자바의 역직렬화는 명백하고 현존하는 위험이다. 이 기술은 지금도 애플리케이션에서 직접 혹은, 자바 하부 시스템(RMI(Remote Method Invocation), JMX(Java Management Extension), JMS(Java Messagign System) 같은)을 통해 간접적으로 쓰이고 있기 때문이다. 신뢰할 수 없는 스트림을 역직렬화하면 원격 코드 실행(RCE, Remote Code Execution), 서비스 거부(Dos, Denial-of-Service) 등의 공격으로 이어질 수 있다. 잘못한 게 아무것도 없는 애플리케이션이라도 이런 공격에 취약해질 수 있다.
**CERD 조정 센터 기술 관리자, 로버트 시커드(Robert Seacord)**
>
- `gadget` : 역직렬화 과정에서 호출되어 잠재적으로 위험한 동작을 수행하는 메서드
- 가젯들이 체인으로 엮이면 더욱 피해가 크다.

<br>

### 역직렬화 폭탄(Deserialization Bomb)

역직렬화에 시간이 오래 걸리는 짧은 스트림을 역직렬화하는 것만으로도 서비스 거부 공격에 쉽게 노출될 수 있다.

```java
static byte[] bomb() {
	Set<Object> root = new HashSet<>();
	Set<Object> s1 = root;
	Set<Obejct> s2 = new HashSet<>();
	for (int i = 0; i < 100; i++) {
		Set<Object> t1 = new HashSet<>();
		Set<Object> t2 = new HashSet<>();
		t1.add("foo"); // t1을 t2와 다르게 만든다.
		s1.add(t1); 
		s1.add(t2);
		s2.add(t1); 
		s2.add(t2);
		s1 = t1;
		s2 = t2;
	}
	return serialize(root);
}
```

- 이 객체 그래프는 201개의 HashSet 인스턴스로 구성되며, 그 각각은 3개 이하의 객체 참조를 갖는다. 스트림의 전체 크기는 5,744바이트이다.
- HashSet 인스턴스를 역직렬화하려면 원소들의 해시코드를 계산해야 하는데 hashCode 메서드를 2의 100제곱번 넘게 호출해야 한다. 단 몇 개의 객체만 생성해도 스택 깊이 제한에 걸려버린다.

<br>

## 직렬화 문제에 대처하는 방법

- 가장 좋은 방법은 아무것도 역직렬화하지 않는 것이다.
- 객체와 바이트 시퀀스를 변환해주는 다른 메커니즘(크로스-플랫폼 구조화된 데이터 표현)을 이용하자.

<br>

### 크로스-플랫폼 구조화된 데이터 표현

(cross-platform structured-data representation)

- 자바 직렬화보다 훨씬 간단하다.
- 임의 객체 그래프를 자동으로 직렬화/역직렬화하지 않는다.
- 속성-값 쌍의 집합으로 구성된 간단하고 구조화된 데이터 객체를 사용한다.
- 기본 타입 몇 개와 배열 타입만 지원한다.

**[1] JSON vs 프로토콜 버퍼**

|  | JSON                                             | 프로토콜 버퍼                                                                                            |
| --- |--------------------------------------------------|----------------------------------------------------------------------------------------------------|
| 설계 목적 | 브라우저와 서버의 통신용으로 설계                               | 서버 사이에 데이터를 교환하고 저장하기 위해 설계                                                                        |
| 특징 | - 텍스트 기반이라 사람이 읽을 수 있다.<br> - 데이터를 표현하기 위해 사용한다. | - 이진 표현이라 효율이 높다.<br> - 사람이 읽을 수 있는 텍스트 표현(pbtxt)도 지원한다.<br> - 문서를 위한 스키마(타입)을 제공하며, 올바로 쓰도록 강요한다. |

<Br>

### 대체 방안

> 신뢰할 수 있는 데이터의 역직렬화는 본질적으로 위험하므로 절대로 피해야 한다.
>
- 자바 직렬화를 완전히 배제할 수 없을 때 신뢰할 수 없는 데이터는 절대 역직렬화하지 말자.
- `객체 역직렬화 필터링(java.io.ObjectInputFilter)`를 사용하자.
    - **데이터 스트림이 역직렬화되기 전에 필터를 설치하는 기능**이다.
    - 클래스 단위로, 특정 클래스를 받아들이거나 거부할 수 있다.
    - **모드** (화이트리스트 방식 추천!)
        - `기본 수용` : 블랙리스트에 기록된 잠재적으로 위험한 클래스들을 거부한다.
        - `기본 거부` : 화이트리스트에 기록된 안전하다고 알려진 클래스들만 수용한다.