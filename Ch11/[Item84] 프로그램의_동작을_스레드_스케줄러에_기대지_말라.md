### ⛳️ 목표
- 프로그램의 동작을 스레드 스케줄러에 기대하지 않아야 하는 이유를 알아보자.

<br>

## 📄 핵심 요약

#### **스레드 스케줄러란?**
- 운영체제가 여러 스레드의 실행 순서와 실행 시간을 관리하는 역할을 한다.

#### **스레드 스케줄러에 의존하면 안 되는 이유**
- 1️⃣ **운영체제마다 스케줄링 방식이 다르다.**
    - 특정 환경에서 잘 동작하더라도, 다른 환경에서는 성능이 저하될 수 있다.
- 2️⃣ **예측 불가능한 실행 흐름이 발생할 수 있다.**
    - Thread.yield()나 스레드 우선순위 조정은 기대한 대로 동작하지 않을 가능성이 크다.
- 3️⃣ **성능과 이식성이 떨어진다.**
    - 스레드 수가 과도하게 많으면 **컨텍스트 스위칭 비용이 증가** 하고 **CPU 자원이 낭비** 된다.

---
<br>

### 1. **실행 가능한 스레드 수를 최소화하라**
- 실행 가능한 스레드 수가 많으면 스케줄러의 부담이 커지고, **예측하기 어려운 지연** 이 발생할 수 있다.
- 프로세서 수를 초과하지 않도록 스레드 풀 크기를 조절해야 한다.

```java
ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
```
- CPU 개수만큼의 스레드만 활성화하여 스레드 스케줄러의 개입을 **최소화** 한다.

<br>

### 2. **바쁜 대기(Busy Waiting)를 피하라**
```java
while (true) {
    synchronized (this) {
        if (conditionMet) {
            break;
        }
    }
}
```
- 위와 같은 **바쁜 대기** 는 CPU 를 과도하게 사용하여 **다른 유용한 작업의 실행 기회를 박탈** 한다.
- 대신 **wait() / notify()** 또는 동기화 도구(CountDownLatch 등)를 사용해야 한다.

```java
synchronized (this) {
    while (!conditionMet) {
        wait();
    }
}
```

<br>

### 3. **Thread.yield()를 남용하지 마라**
```java
while (!conditionMet) {
    Thread.yield();
}
```
- Thread.yield()는 Java 에서 현재 실행 중인 스레드가 CPU 를 다른 스레드에 양보하도록 하는 메서드이다. 
- yield()는 스레드 스케줄러에 힌트를 줄 뿐이며, 항상 기대한 대로 동작하지 않는다.
- JVM 마다 다르게 동작하며, 일부에서는 성능이 오히려 저하될 수 있다.
- 대신 적절한 **동기화 메커니즘** 을 사용해야 한다.

<br>

### 4. **스레드 우선순위를 믿지 마라**
```java
thread.setPriority(Thread.MAX_PRIORITY);
```
- 스레드 우선순위는 **운영체제와 JVM 구현에 따라 동작 방식이 다르다.**
- 특정 스레드가 CPU 시간을 충분히 얻지 못하는 문제를 해결하려고 우선순위를 조정하는 것은 **잘못된 접근** 이다.
- **진짜 원인을 찾아 해결하는 것이 중요** 하다.

<br>

### 💡 **핵심 정리**
- 스레드 스케줄러에 의존하면 프로그램의 성능과 이식성이 저하된다.
- 실행 가능한 스레드 수를 최소화하여 스케줄러의 개입을 줄여야 한다.
- 바쁜 대기(Busy Waiting)는 피하고, 적절한 동기화 기법을 사용하라.
- Thread.yield()와 스레드 우선순위 조정은 믿을 수 없다.
- 멀티스레드 환경에서는 애플리케이션 구조를 올바르게 설계하는 것이 최우선이다.