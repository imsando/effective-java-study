# 스레드 안정성 수준을 문서화하라

## ⛳️ 목표

모든 클래스가 스레드 안정성 정보를 문서화해야 하는 이유를 알아보자

<br>

## 📄 핵심 요약

- 멀티스레드 환경에서는 클래스가 지원하는 스레드 안정성 수준을 정확히 명시해야 한다.
- `조건부 스레드 안전 클래스`는 메서드를 어떤 순서로 호출할 때 외부 동기화가 요구되고, 어떤 락을 얻어야 하는지 알려줘야 한다.
- `무조건적 스레드 안전 클래스`를 작성할 때는 synchronized 메서드가 아닌 비공개 락 객체를 사용해야 동기화 메커니즘을 깨뜨리지 않을 수 있다.

---

> API 문서에 동기화와 관련된 내용이 없으면, 사용자는 동기화를 충분히 하지 못하거나, 지나치게 하여 심각한 오류를 초래할 수 있다.
>

<br>

## API 문서 - 스레드 안정성 수준

- 자바독이 기본 옵션에서 생성한 API 문서에는 `Synchronized` 한정자가 포함되지 않는다.
    - 메서드 선언에 한정자를 선언할지는 구현 이슈이기 때문이다.
- 멀티스레드 환경에서도 API를 안전하게 사용하게 하려면 클래스가 지원하는 스레드 안정성 수준을 정확히 명시해야 한다.

<br>

### **스레드 안정성 수준 목록 (높은 순)**

**[1] 불변(immutable)**

내부 동기화는 물론, 외부 동기화도 필요 없다.

- String, Long, BigInteger 등
- 스레드 안정성 애너테이션 `@Immutable`과 일치

<br>

**[2] 무조건적 스레드 안전(unconditionally thread-safe)** 인스턴스는 수정될 수 있으나, 내부에서 동기화 작업이 완료되어 별도의 외부 동기화가 필요없다.

- AtomicLong, ConcurrentHashMap 등
- 스레드 안정성 애너테이션 `@ThreadSafe`에 속함

<br>

**[3] 조건부 스레드 안전(conditionally thread-safe)**

무조건적 스레드 완성과 같으나, 일부 메서드는 동시에 사용하려면 외부 동기화가 필요하다.

- Collections.synchronized 래퍼 클래스가 반환한 컬렉션들
- 스레드 안정성 애너테이션 `@ThreadSafe` 에 속함

<br>

**[4] 스레드 안전하지 않음(not thread-safe)**

각각의(혹은 일련의) 메서드 호출을 클라이언트가 선택한 외부 동기화 메커니즘으로 감싸야 한다.

- ArrayList, HashMap 같은 기본 컬렉션
- 스레드 안정성 애너테이션 `@NotThreadSafe`와 일치

<br>

**[5] 스레드 적대적(thread-hostile)**

모든 메서드 호출을 외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않다.

<br>

## 조건부 스레드 안전 클래스 문서화하는 법

- 어떤 순서로 호출할 때 외부 동기화가 필요한지 작성
- 그 순서로 호출하려면 어떤 락 혹은 (드물게) 락들을 얻어야 하는지 안내 필요

```java
// Collections.synchronizedMap의 API 문서
synchronizedMap이 반환한 맵의 컬렉션 뷰를 순회하려면 반드시 그 맵을 락으로 사용해 수동으로 동기화하라.

Map<K, V> m = Collections.synchronizedMap(new HashMap<>());
Set<K> s = m.keySet(); // 동기화 블록 밖에 있어도 된다.
...
synchronized(m) { // s가 아닌 m을 사용해 동기화해야 한다!
	for (K key : s) {
		key.f();
	}
}

이대로 따르지 않으면 동작을 예측할 수 없다.
```

<br>

## 무조건적 스레드 안전 클래스 주의점

- 클래스가 외부에서 사용할 수 있는 락을 제공하면 클라이언트에서 일련의 메서드 호출을 원자적으로 수행할 수 있다.
- 하지만 내부에서 처리하는 고성능 동시성 제어 메커니즘과 혼용할 수 없다.
- 클라이언트가 공개된 락을 오래 쥐고 놓지 않는 `서비스 거부 공격(denal-of-service attack)`을 수행할 수도 있다.

<br>

### 비공개 락 - 서비스 공격을 막기 위한 방법

synchronized 메서드 대신 비공개 락 객체를 사용해야 한다.

```java
private final Object lock = new Object();

public void foo() {
	synchronized(lock) {
		...
	}
}
```

- lock 필드를 final로 선언하여 락 객체가 교체되는 일을 예방한다.
- 무조건적 스레드 안전 클래스에서만 사용할 수 있다.